import chess
from node import Node
import numpy as np
import random
import sys
import heuristics

'''
Exploration/Exploitation function. currentNode.v + np.sqrt(2) *
        (np.sqrt(np.log(currentNode.N + np.exp(1) + (10**-7)) / (currentNode.n + (10**-11))))
        as defined by the book. Notice the terms to avoid DivisionByZero.

Parameters:
    - currentNode: node, the node that has been passed to the UCB1 algorithm, is a child
    of the current node from selection

Returns:
    The UCB1 value calculated by the formula for the child.
'''
def ucb1(currentNode):
    return currentNode.v + np.sqrt(2) * \
        (np.sqrt(np.log(currentNode.N + np.exp(1) + (10**-7)) / (currentNode.n + (10**-11))))


'''
selection:

The selection algorithm. Iterate through all the child of the given state and select 
the one with highest UCB value.

Parameters:
    - currentNode - Node, the current node to select a child from

Returns:
    The child of the current node with the highest UCB1 value
'''
def selection(currentNode): #SELECTION
    # if player == "white":
    selection = None
    ucb_value = -np.infty
    for child in currentNode.children:
        child_ucb = ucb1(child)
        if child_ucb > ucb_value:
            ucb_value = child_ucb
            selection = child
        return selection

'''
Recursively keep on calling the 
child with maximum UCB1 till we reach the end of the tree or number of simulations.

Parameters:
    currentNode - Node, the current node in question to expand
    player - String, either the black or white player.

Returns:
    The currentNode as selected by repeated calls to selection, either returned because end of 
    tree reached, or simulations ended
'''
def expansion(currentNode, player): #EXPANSION
    if len(currentNode.children) == 0:
        return currentNode
    if player == "white":
        descendant = selection(currentNode)
        return expansion(descendant, "black")
    if player == "black":
        descendant = selection(currentNode)
        return (expansion(descendant, "white"))

'''
Upon getting a Node from expansion, playout will make moves based on heuristic function or random value
till we reach end of the game and will return leaf node. 
If we reach the end of the game, we evaluate the result of the game and send values back accordingly.

Parameters:
    - currentNode - Node, playout from the current Node in question
    - depth - Int, experimental parameter for depth efficiency testing

Returns:
    The currentNode that we ended with and the reward associated with reaching that node per the end game
    result.
'''
def playout(currentNode, depth): #ROLLOUT
    if currentNode.board_state.is_game_over():
        chessboard = currentNode.board_state
        if chessboard.result() == "1-0":
            return (currentNode, 1)
        elif chessboard.result() == "0-1":
            return (currentNode,0)
        else:
            return (currentNode,0.5)
    elif depth == 0:
        val = currentNode.get_heuristic("W", update_v=False)
        if val > 0:
            return (currentNode, 1)
        elif val < 0:
            return (currentNode, 0)
        else:
            return (currentNode, 0.5)

    legalMoves = list(currentNode.board_state.legal_moves)
    possibleMoves = [currentNode.board_state.san(i) for i in legalMoves]
    values = []
    for i in possibleMoves:
        descendant = Node()
        state = chess.Board(currentNode.board_state.fen())
        state.push_san(i)

        descendant.board_state = state
        descendant.parent = currentNode
        currentNode.children.add(descendant)
        val = descendant.get_heuristic("W", update_v=False)
        values.append(val+1)
    values = np.array(values, dtype="float64")
    if np.amin(values) < 0:
        values += -1*np.amin(values)
    rng = np.random.default_rng()
    return playout(random.choice(list(currentNode.children)), depth-1)
    

'''
Receives the final node and reward from playout. Traverses that reward till the root of the tree which will
in turn update the Node parameters N, n and v, that impact the UCB1 values of each node in the path.

Parameters:
    - currentNode - Node, the current node in question
    - reward - Float, the reward associated with the currentNode being the leaf

Returns:
    Returns the currentNode. 
'''

def backpropagate(currentNode, result): #BACKPROPAGATE
    currentNode.n += 1
    currentNode.v += result
    while currentNode.parent is not None:
        currentNode.N += 1
        currentNode = currentNode.parent
    return currentNode


'''
mcts:

The driver for the MCTS algorithm. Gnerates the possible moves, and sets
the number of simulations for the selection, expansion, playout and backprop
functions. Calculates the final move to return

Parameters:
    - currentNode - Node, the current node in question, generated by host_game
    - kriegspiel - Boolean, whether we are playing kriegspiel or not

Returns:
    Returns the node that is selected by MCTS, the move that is played on the board
'''
def mcts(currentNode, kriegspiel=False):
    legalMoves = list(currentNode.board_state.legal_moves)
    possibleMoves = [currentNode.board_state.san(i) for i in legalMoves]
    move_map = dict()
    for i in possibleMoves:
        # Get FEN Notation of Board
        state = chess.Board(currentNode.board_state.fen())
        state.push_san(i) 
        descendant = Node()
        descendant.board_state = state
        descendant.parent = currentNode
        currentNode.children.add(descendant)
        move_map[descendant] = i

    sims = 200  # I.E "Until We Run Out of Time..."
    for sim_num in range(sims):
        child = selection(currentNode, "white", -np.infty)
        leaf = expansion(child, "white")
        finalNode, reward = playout(leaf, 0)
        currentNode = backpropagate(finalNode, reward)

    move = ''
    ucb_value = -np.infty
    for child in currentNode.children:
        child_ucb = ucb1(child)
        if child_ucb > ucb_value:
            ucb_value = child_ucb
            move = move_map[child]
    return move
